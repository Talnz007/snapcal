<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üì∏ SnapCal ‚Äì Offline Math Solver</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- MathJax config for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      startup: { ready: () => MathJax.startup.defaultReady() }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="bg-gradient-to-br from-indigo-100 via-blue-50 to-purple-100 min-h-screen flex items-center justify-center p-4 font-sans">
  <div class="bg-white shadow-2xl rounded-2xl p-8 w-full max-w-md mx-auto border border-gray-200">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-4xl font-extrabold text-indigo-700 mb-2">üì∏ SnapCal</h1>
      <p class="text-gray-600 text-lg">Offline Math Solver</p>
    </div>

    <!-- Input Section -->
    <div class="space-y-6">
      <div>
        <label for="imageInput" class="block text-sm font-semibold text-gray-700 mb-2 flex items-center">
          <span class="mr-2">üì∑</span> Select or snap an image
        </label>
        <input id="imageInput" type="file" accept="image/*" capture="environment" class="block w-full text-sm text-gray-500 file:mr-4 file:py-3 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-100 file:text-indigo-800 hover:file:bg-indigo-200 transition-all" />
      </div>

      <div id="ocrStatus" class="text-sm text-gray-500 bg-gray-50 p-3 rounded-lg"></div>

      <button id="solveBtn" class="w-full bg-indigo-600 text-white py-3 px-4 rounded-lg hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-all font-semibold shadow-md hover:shadow-lg">
        üßÆ Solve Problem
      </button>
    </div>

    <!-- Output Section -->
    <div id="output" class="mt-8 p-4 bg-gray-50 rounded-lg min-h-[200px] text-gray-800 border border-gray-200 shadow-inner"></div>

    <!-- Status -->
    <div id="apiStatus" class="mt-6 text-sm text-center text-gray-500 bg-gray-100 p-3 rounded-lg"></div>
  </div>

  <script>
    // Core variables
    let session = null;
    let extractedText = '';

    // OCR function
    async function performOCR(imageFile) {
      document.getElementById("ocrStatus").innerHTML = "<span class='text-blue-600'>üîç Extracting text from image‚Ä¶</span>";
      try {
        const { data: { text } } = await Tesseract.recognize(imageFile, 'eng', {
          logger: m => console.log('OCR progress:', m)
        });
        extractedText = text.trim();
        document.getElementById("ocrStatus").innerHTML = `<span class='text-green-600'>‚úÖ Extracted text: <strong>"${extractedText}"</strong></span>`;
        console.log("OCR result:", extractedText);
        return extractedText;
      } catch (e) {
        document.getElementById("ocrStatus").innerHTML = `<span class='text-red-600'>‚ùå OCR failed: ${e.message}</span>`;
        return '';
      }
    }

    // Updated API detection with streaming preference
    async function checkAvailability(retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          // Prefer Chat API for streaming (even if deprecated)
          if (typeof ai !== "undefined" && ai.canCreateTextSession) {
            const availability = await ai.canCreateTextSession();
            if (availability === "readily") {
              document.getElementById("apiStatus").innerHTML = "‚úÖ Gemini Nano ready (Streaming Chat API)!";
              return "chat";
            }
          } else if (typeof LanguageModel !== "undefined") {
            const availability = await LanguageModel.availability();
            if (availability === "available") {
              document.getElementById("apiStatus").innerHTML = "‚úÖ Gemini Nano ready (Prompt API)!";
              return "prompt";
            }
          }
          document.getElementById("apiStatus").innerHTML = "‚ùå Gemini Nano API not available.";
          return false;
        } catch (err) {
          console.error("Availability check error:", err);
          document.getElementById("apiStatus").innerHTML = `‚ö†Ô∏è Error: ${err.message}`;
          if (i === retries - 1) return false;
        }
      }
    }

    async function initSession(apiType) {
      if (session) return session;
      try {
        if (apiType === "chat") {
          session = await ai.createTextSession();
        } else {
          session = await LanguageModel.create({ temperature: 0.3, topK: 3, outputLanguage: 'en' });
        }
        console.log("‚úÖ Session created:", session);
        return session;
      } catch (e) {
        console.error("Session creation failed:", e);
        alert("Failed to create session: " + e.message);
      }
    }

    // OCR on image selection
    document.getElementById("imageInput").addEventListener("change", async (event) => {
      const imageFile = event.target.files[0];
      if (imageFile) {
        await performOCR(imageFile);
      }
    });

    document.getElementById("solveBtn").addEventListener("click", async () => {
      const apiType = await checkAvailability();
      if (!apiType) return;

      if (!extractedText) {
        alert("Please select an image and wait for OCR to extract text.");
        return;
      }

      const aiSession = await initSession(apiType);
      const button = document.getElementById("solveBtn");
      button.disabled = true;
      button.textContent = "‚è≥ Solving‚Ä¶";

      const prompt = `
Solve this math problem: "${extractedText}"

Return your answer in JSON:
{
  "answer": "the final answer in LaTeX format (e.g. x = 5)",
  "steps": ["Step 1: ...", "Step 2: ..."]
}`;

      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = "<div class='text-center text-gray-500'>‚è≥ Solving‚Ä¶</div>";

      try {
        let fullResponse = '';
        let parsed;

        if (apiType === "chat") {
          // Streaming with Chat API
          const stream = aiSession.promptStreaming(prompt);
          let chunkCount = 0;
          for await (const chunk of stream) {
            fullResponse += chunk;
            chunkCount++;
            // Update UI progressively every few chunks
            if (chunkCount % 5 === 0) {
              updateUI(fullResponse);
            }
          }
          updateUI(fullResponse); // Final update
        } else {
          // Non-streaming with Prompt API
          const result = await aiSession.prompt(prompt);
          fullResponse = result;
          updateUI(fullResponse);
        }

        // Parse and finalize UI
        try {
          let jsonMatch = fullResponse.match(/```json\s*(\{[\s\S]*?\})\s*```/);
          if (!jsonMatch) {
            jsonMatch = fullResponse.match(/\{[\s\S]*?\}/);
          }
          if (jsonMatch) {
            let jsonString = jsonMatch[1] || jsonMatch[0];
            jsonString = jsonString.replace(/\\/g, '\\\\');
            parsed = JSON.parse(jsonString);
            console.log("Parsed JSON:", parsed);
          } else {
            throw new Error("No JSON found");
          }
        } catch (parseError) {
          console.error("JSON parsing failed:", parseError);
          parsed = { answer: fullResponse, steps: [] };
        }

        finalizeUI(parsed);
      } catch (e) {
        console.error("Error solving:", e);
        document.getElementById("output").innerHTML = `<p class="text-red-600 text-center">‚ùå ${e.message}</p>`;
      } finally {
        button.disabled = false;
        button.textContent = "üßÆ Solve Problem";
      }
    });

    // Progressive UI update during streaming
    function updateUI(response) {
      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = `<div class="text-gray-700 break-words">${response.replace(/\n/g, '<br>')}</div>`;
    }

    // Finalize UI with parsed LaTeX
    async function finalizeUI(parsed) {
      const outputDiv = document.getElementById("output");
      outputDiv.innerHTML = `
        <div class="mb-4">
          <h3 class="text-lg font-bold text-indigo-700 mb-2">Answer:</h3>
          <div class="text-xl bg-white p-3 rounded border shadow-sm" id="answerDiv">\\[${parsed.answer || 'No answer'}\\]</div>
        </div>
        <div>
          <h3 class="text-lg font-bold text-indigo-700 mb-2">Steps:</h3>
          <div class="space-y-2">
            ${(parsed.steps || []).map((s, i) => `<div class="bg-white p-3 rounded border shadow-sm break-words">${i + 1}. ${s}</div>`).join("")}
          </div>
        </div>
      `;

      // Render LaTeX
      if (window.MathJax) {
        await MathJax.startup.promise;
        await MathJax.typesetPromise([outputDiv]);
        console.log("MathJax rendered successfully");
      } else {
        console.warn("MathJax not loaded");
      }
    }

    // Run diagnostics on page load
    checkAvailability();
  </script>
</body>
</html>